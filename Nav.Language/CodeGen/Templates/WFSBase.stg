delimiters "<", ">"

// Common.stg und CodeGenFacts.stg werden immer importiert

Begin(model, context) ::=<<
<writeFileHeader(context)>
<writeUsingDirectives(model.UsingNamespaces)>

namespace <model.WflNamespace> {
    <writeTaskAnnotation(model.RelativeSyntaxFileName, model.Task.TaskName)>
    public abstract partial class <model.WfsBaseTypeName>: <model.WfsBaseBaseTypeName> {
        
        <writeFieldDeclarationCollapsibleList(model.TaskBegins)><\\>

        public <model.WfsBaseTypeName>(Pharmatechnik.Apotheke.XTplus.Framework.NavigationEngine.IWFL.IClientSideWFS clientSideWFS) {}

        public <model.WfsBaseTypeName>(<writeParameterList(model.TaskBegins)>) {
            <writeFieldInitList(model.TaskBegins)>
        }

        <writeInitTransitionCollapsibleList(model.InitTransitions)><\\>

        <writeExitTransitionCollapsibleList(model.ExitTransitions)><\\>

        <writeTriggerTransitionCollapsibleList(model.TriggerTransitions)><\\>

        <writeBeginWrapperCollapsibleList(model.BeginWrappers)><\\>

        protected INavCommandBody TaskResult(<model.TaskResult.ParameterType> <model.TaskResult.ParameterName>) {
            return InternalTaskResult(<model.TaskResult.ParameterName>);
        }

        static string OfTypeText(INavCommandBody body) {
            if (body == null) {
                return "null";
            }
            if (body is TaskCall) {
                return $"of task node {((TaskCall) body).Node.NodeName}";
            }
            return $"of type {body.GetType().FullName}";
        }
    }

    <writeTaskAnnotation(model.RelativeSyntaxFileName, model.Task.TaskName)>
    public partial class <model.WfsTypeName>: <model.WfsBaseTypeName>, <InterfacePrefix()><model.Task.TaskNamePascalcase><WfsClassSuffix()>, <BeginInterfacePrefix()><model.Task.TaskNamePascalcase><WfsClassSuffix()> {

        <writeFieldDeclarationCollapsibleList(model.TaskParameter)><\\>

        public <model.WfsTypeName>(Pharmatechnik.Apotheke.XTplus.Framework.NavigationEngine.IWFL.IClientSideWFS clientSideWFS): base(clientSideWFS) {}

        public <model.WfsTypeName>(<writeParameterList([model.TaskBegins, model.TaskParameter])>)
            :base(<writeParameterExpressions(model.TaskBegins)>) {
            <writeFieldInitList(model.TaskParameter)>
        }
    }
}
>>

writeInitTransitionCollapsibleList(initTransitions) ::=<<
<initTransitions:writeInitTransition(); separator="\r\n">
>>

writeInitTransition(initTransition) ::=<<
<if(initTransition.GenerateAbstractMethod)>
<writeNavInitAnnotation(initTransition.NodeName)>
public abstract IINIT_TASK <initTransition.BeginMethodName>(<writeParameterList(initTransition.Parameter)>);
<else>
<writeNavInitAnnotation(initTransition.NodeName)>
public virtual IINIT_TASK <initTransition.BeginMethodName>(<writeParameterList(initTransition.Parameter)>) {
    var body = <initTransition.BeginLogicMethodName>(<writeParameterExpressions([initTransition.Parameter, initTransition.TaskBeginFields])>);
    <writeTransitionCallBlock(initTransition)>
    throw new InvalidOperationException($"<initTransition.BeginLogicMethodName>(<writeParameterExpressionsInline(initTransition.Parameter)>) returned unexpected result '{OfTypeText(body)}'.");
}

<writeNavInitAnnotation(initTransition.NodeName)>
protected abstract INavCommandBody <initTransition.BeginLogicMethodName>(<writeParameterList([initTransition.Parameter, initTransition.TaskBegins])>);
<endif>
>>

writeExitTransitionCollapsibleList(exitTransitions) ::=<<
<exitTransitions:writeExitTransition(); separator="\r\n">
>>

writeExitTransition(exitTransition) ::=<<
<if(exitTransition.GenerateAbstractMethod)>
<writeNavExitAnnotation(exitTransition.NodeName)>
protected abstract INavCommand <exitTransition.AfterMethodName>(<writeParameterList(exitTransition.TaskResult)>);
<else>
<writeNavExitAnnotation(exitTransition.NodeName)>
private INavCommand <exitTransition.AfterMethodName>(<writeParameterList(exitTransition.TaskResult)>) {
    var body = <exitTransition.AfterLogicMethodName>(<writeParameterExpressionsInline([exitTransition.TaskResult, exitTransition.TaskBeginFields])>);
    <writeTransitionCallBlock(exitTransition)>
    throw new InvalidOperationException($"<exitTransition.AfterLogicMethodName>(<writeParameterExpressionsInline(exitTransition.TaskResult)>) returned unexpected result '{OfTypeText(body)}'.");
}

<writeNavExitAnnotation(exitTransition.NodeName)>
protected abstract INavCommandBody <exitTransition.AfterLogicMethodName>(<writeParameterList([exitTransition.TaskResult, exitTransition.TaskBegins])>);
<endif>
>>

writeTriggerTransitionCollapsibleList(triggerTransitions) ::=<<
<triggerTransitions:writeTriggerTransition(); separator="\r\n\r\n">

>>

writeTriggerTransition(triggerTransition) ::=<<
<writeTriggerAnnotation(triggerTransition.TriggerName)>
public virtual INavCommand <triggerTransition.TriggerMethodName>(<writeParameterList(triggerTransition.ViewParameter)>) {
    var body = <triggerTransition.TriggerLogicMethodName>(<writeParameterExpressionsInline([triggerTransition.ViewParameter, triggerTransition.TaskBeginFields])>);    
    <writeTransitionCallBlock(triggerTransition)>
    throw new InvalidOperationException($"<triggerTransition.TriggerLogicMethodName>(<writeParameterExpressionsInline(triggerTransition.ViewParameter)>) returned unexpected result '{OfTypeText(body)}'.");
}

<writeTriggerAnnotation(triggerTransition.TriggerName)>
protected abstract INavCommandBody <triggerTransition.TriggerLogicMethodName>(<writeParameterList([triggerTransition.ViewParameter, triggerTransition.TaskBegins])>);
>>

writeBeginWrapperCollapsibleList(beginWrapperModels) ::=<<
<beginWrapperModels:writeBeginWrapper(); separator="\r\n\r\n">

>>

writeBeginWrapper(beginWrapperModel) ::=<<
static readonly TaskNode <beginWrapperModel.TaskNodeName>Node = TaskNode.Create("<beginWrapperModel.TaskNodeName>");

<writeWrapperBeginMethodList(beginWrapperModel.TaskBegins)>
>>

writeWrapperBeginMethodList(taskBegins) ::=<<
<taskBegins:writeWrapperBeginMethod(); separator="\r\n\r\n">
>>

writeWrapperBeginMethod(ctorModel) ::=<<
<writeInitCallAnnotation(ctorModel.TaskBeginParameter.ParameterType)>
protected INavCommandBody <BeginMethodPrefix()><ctorModel.TaskNodeName>(<writeParameterList([ctorModel.TaskBeginParameter, ctorModel.TaskParameter])>) {
    <if(ctorModel.NotImplemented)>
    return new TaskCall(<ctorModel.TaskNodeName>Node, null);
    <else>
    return new TaskCall(<ctorModel.TaskNodeName>Node, () => <ctorModel.TaskBeginParameter.ParameterName>.<BeginMethodPrefix()>(<writeParameterExpressionsInline(ctorModel.TaskParameter)>));
    <endif>
}
>>

writeTransitionCallBlock(transition) ::=<<
var taskCall = body as TaskCall;
<transition.ReachableCalls:writeCall(); separator="\r\n">
if(body is CANCEL) {
    return (CANCEL)body;
}
>>

writeCall(call) ::=<<
<(call.TemplateName)(call)>
>>

goToExit(call) ::=<<
if (body is TASK_RESULT) {
    return (TASK_RESULT) body;
}
>>

goToEnd(call) ::=<<
if (body is END) {
    return EndNonModal();
}
>>

openModalTask(taskCall) ::=<<
if(taskCall?.Node == <taskCall.PascalCaseName>Node ) {
    <if(taskCall.NotImplemented)>
    throw new NotImplementedException("Task <taskCall.Name> is specified as [notimplemented]");
    <else>
    return OpenModalTask\<<taskCall.TaskResult.ParameterType>\>(taskCall.BeginWrapper, <ExitMethodPrefix()><taskCall.PascalCaseName>);
    <endif>
}
>>

startNonModalTask(taskCall) ::=<<
if(taskCall?.Node == <taskCall.PascalCaseName>Node ) {
    <if(taskCall.NotImplemented)>
    throw new NotImplementedException("Task <taskCall.Name> is specified as [notimplemented]");
    <else>
    return StartNonModalTask(taskCall.BeginWrapper, <ExitMethodPrefix()><taskCall.PascalCaseName>);
    <endif>
}
>>

gotoTask(taskCall) ::=<<
if(taskCall?.Node == <taskCall.PascalCaseName>Node ) {
    <if(taskCall.NotImplemented)>
    throw new NotImplementedException("Task <taskCall.Name> is specified as [notimplemented]");
    <else>
    return GotoTask\<<taskCall.TaskResult.ParameterType>\>(taskCall.BeginWrapper, <ExitMethodPrefix()><taskCall.PascalCaseName>);
    <endif>
}
>>

openModalGUI(call) ::=<<
if(body is <call.PascalCaseName><ToClassNameSuffix()>) {
    return OpenModalGUI((<call.PascalCaseName><ToClassNameSuffix()>) body);
}
>>

startNonModalGUI(call) ::=<<
if(body is <call.PascalCaseName><ToClassNameSuffix()>) {
    return StartNonModalGUI((<call.PascalCaseName><ToClassNameSuffix()>) body);
}
>>

gotoGUI(call) ::=<<
if(body is <call.PascalCaseName><ToClassNameSuffix()>) {
    return GotoGUI((<call.PascalCaseName><ToClassNameSuffix()>) body);
}
>>