delimiters "<", ">"

Begin(model, context) ::=<<
<writeFileHeader(context)>
<writeUsingDirectives(model.UsingNamespaces)>

namespace <model.WflNamespace> {
    <writeTaskAnnotation(model.RelativeSyntaxFileName, model.Task.TaskName)>
    public abstract partial class <model.WfsBaseTypeName>: <model.WfsBaseBaseTypeName> {
        
        <writeFieldDeclarationCollapsibleList(model.TaskBegins)><\\>

        public <model.WfsBaseTypeName>(Pharmatechnik.Apotheke.XTplus.Framework.NavigationEngine.IWFL.IClientSideWFS clientSideWFS) {}

        public <model.WfsBaseTypeName>(<writeParameterList(model.TaskBegins)>) {
            <writeFieldInitList(model.TaskBegins)>
        }

        <writeInitTransitionCollapsibleList(model.InitTransitions)><\\>

        <writeExitTransitionCollapsibleList(model.ExitTransitions)><\\>

        <writeTriggerTransitionCollapsibleList(model.TriggerTransitions)><\\>

        <writeBeginWrapperCollapsibleList(model.BeginWrappers)><\\>

        protected INavCommandBody TaskResult(<model.TaskResult.ParameterType> <model.TaskResult.ParameterName>) {
            return InternalTaskResult(<model.TaskResult.ParameterName>);
        }

        static string OfTypeText(object value) {
            return value == null ? "null" : $"of type {value.GetType().FullName}";
        }
    }

    <writeTaskAnnotation(model.RelativeSyntaxFileName, model.Task.TaskName)>
    public abstract partial class <model.WfsTypeName>: <model.WfsBaseTypeName>, <InterfacePrefix()><model.Task.TaskNamePascalcase><WfsClassSuffix()>, <BeginInterfacePrefix()><model.Task.TaskNamePascalcase><WfsClassSuffix()> {
        <if(model.TaskParameter)>

        <model.TaskParameter:writeFieldDeclaration(); separator="\r\n">

        <else>

        <endif>
        public <model.WfsTypeName>(Pharmatechnik.Apotheke.XTplus.Framework.NavigationEngine.IWFL.IClientSideWFS clientSideWFS): base(clientSideWFS) {}

        public <model.WfsTypeName>(<writeParameterList([model.TaskBegins, model.TaskParameter])>)
            :base(<writeParameterExpressions(model.TaskBegins)>) {
            <writeFieldInitList(model.TaskParameter)>
        }
    }
}
>>

writeInitTransitionCollapsibleList(initTransitions) ::=<<
<initTransitions:writeInitTransition(); separator="\r\n\r\n">

>>

writeInitTransition(initTransition) ::=<<
protected abstract INavCommandBody <BeginMethodPrefix()><LogicMethodSuffix()>(<writeParameterList([initTransition.Parameter, initTransition.TaskBeginFields])>);

public virtual IINIT_TASK <BeginMethodPrefix()>(<writeParameterList(initTransition.Parameter)>) {
    INavCommandBody body = <BeginMethodPrefix()><LogicMethodSuffix()>(<writeParameterExpressions([initTransition.Parameter, initTransition.TaskBeginFields])>);
    <writeTransitionCallBlock(initTransition)>
    throw new InvalidOperationException($"<BeginMethodPrefix()><LogicMethodSuffix()>(<writeParameterExpressionsInline(initTransition.Parameter)> returned unexpected result '{OfTypeText(body)}'.");
}
>>

writeExitTransitionCollapsibleList(exitTransitions) ::=<<
<exitTransitions:writeExitTransition(); separator="\r\n\r\n">

>>

writeExitTransition(exitTransition) ::=<<
private INavCommand <ExitMethodPrefix()><exitTransition.TaskNamePascalcase>(<writeParameterList(exitTransition.TaskResult)>) {
    var body = <ExitMethodPrefix()><exitTransition.TaskNamePascalcase><LogicMethodSuffix()>(<writeParameterExpressionsInline([exitTransition.TaskResult, exitTransition.TaskBeginFields])>);
    <writeTransitionCallBlock(exitTransition)>
    // TODO Throw Exception
    throw new InvalidOperationException();
}

protected abstract INavCommandBody <ExitMethodPrefix()><exitTransition.TaskNamePascalcase><LogicMethodSuffix()>(<writeParameterList([exitTransition.TaskResult, exitTransition.TaskBegins])>);
>>

writeTriggerTransitionCollapsibleList(triggerTransitions) ::=<<
<triggerTransitions:writeTriggerTransition(); separator="\r\n\r\n">

>>

writeTriggerTransition(triggerTransition) ::=<<
public virtual INavCommand <triggerTransition.TriggerNamePascalcase>(<writeParameterList(triggerTransition.ViewParameter)>) {
    var body = <triggerTransition.TriggerNamePascalcase><LogicMethodSuffix()>(<writeParameterExpressionsInline([triggerTransition.ViewParameter, triggerTransition.TaskBeginFields])>);
    <writeTransitionCallBlock(triggerTransition)>
    // TODO Throw Exception
    throw new InvalidOperationException();
}

protected abstract INavCommandBody <triggerTransition.TriggerNamePascalcase><LogicMethodSuffix()>(<writeParameterList([triggerTransition.ViewParameter, triggerTransition.TaskBeginFields])>);
>>


writeBeginWrapperCollapsibleList(beginWrapperModels) ::=<<
<beginWrapperModels:writeBeginWrapper(); separator="\r\n\r\n">

>>

writeBeginWrapper(beginWrapperModel) ::=<<
<writeWrapperBeginMethodList(beginWrapperModel.Ctors)>

protected class Begin<beginWrapperModel.TaskNodeName>Wrapper: INavCommandBody {
    internal readonly BeginTaskWrapper BeginWrapper;
    <writeBeginWrapperCtorList(beginWrapperModel.Ctors)>
}
>>

writeWrapperBeginMethodList(ctorModels) ::=<<
<ctorModels:writeWrapperBeginMethod(); separator="\r\n\r\n">
>>

writeWrapperBeginMethod(ctorModel) ::=<<
<writeInitCallAnnotation(ctorModel.TaskInitParameter.ParameterType)>
protected Begin<beginWrapperModel.TaskNodeName>Wrapper Begin<ctorModel.TaskNodeName>(<writeParameterList([ctorModel.TaskBeginParameter, ctorModel.TaskParameter])>) {
    return new Begin<beginWrapperModel.TaskNodeName>Wrapper(<writeParameterExpressionsInline([ctorModel.TaskBeginParameter, ctorModel.TaskParameter])>);
}
>>

writeBeginWrapperCtorList(ctorModels) ::=<<
<ctorModels:writeBeginWrapperCtor(); separator="\r\n">
>>

writeBeginWrapperCtor(ctorModel) ::=<<
internal Begin<ctorModel.TaskNodeName>Wrapper(<writeParameterList([ctorModel.TaskBeginParameter, ctorModel.TaskParameter])>) {
    BeginWrapper = () => <ctorModel.TaskBeginParameter.ParameterName>.Begin(<writeParameterExpressionsInline(ctorModel.TaskParameter)>);
}
>>

writeTransitionCallBlock(transition) ::=<<
<transition.ReachableCalls:writeCall(); separator="\r\n">
if(body is CANCEL) {
    return (CANCEL)body;
}
>>

writeCall(call) ::=<<
<(call.TemplateName)(call)>
>>

goToExit(call) ::=<<
if (body is TASK_RESULT) {
    return (TASK_RESULT) body;
}
>>

goToEnd(call) ::=<<
if (body is END) {
    return EndNonModal();
}
>>

openModalTask(call) ::=<<
<startTaskImpl(call, "OpenModalTask")>
>>

startNonModalTask(call) ::=<<
<startTaskImpl(call, "StartNonModalTask")>
>>

gotoTask(call) ::=<<
<startTaskImpl(call, "GotoTask")>
>>

startTaskImpl(call, method) ::=<<
if(body is Begin<call.PascalCaseName>Wrapper) {
    return <method>\<bool>(((Begin<call.PascalCaseName>Wrapper) body).BeginWrapper, <ExitMethodPrefix()><call.PascalCaseName>);
}
>>


openModalGUI(call) ::=<<
<openGuiImpl(call, "OpenModalGUI")>
>>

startNonModalGUI(call) ::=<<
<openGuiImpl(call, "StartNonModalGUI")>
>>

gotoGUI(call) ::=<<
<openGuiImpl(call, "GotoGUI")>
>>

openGuiImpl(call, method) ::=<<
if(body is <call.PascalCaseName><ToClassNameSuffix()>) {
    return <method>((<call.PascalCaseName><ToClassNameSuffix()>) body);
}
>>
